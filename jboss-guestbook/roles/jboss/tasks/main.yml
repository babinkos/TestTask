---
# tasks file for jboss/wildfly
- debug:
    msg: "System {{ inventory_hostname }} has OS type: {{ ansible_distribution }}"

- name: install openjdk, unzip
  become: yes
  apt:
    name: "{{ item }}"
    state: latest
  with_items:
    - 'default-jdk'
    - 'unzip'
    - 'python-lxml'
  when: ansible_distribution == 'Debian' or ansible_distribution == 'Ubuntu'

- name: Check that the jboss directory already exists
  become: yes
  stat:
    path: "{{ jboss_rootdir }}"
  register: dirstate

- debug:
    msg: "filepath {{ jboss_rootdir }} state exists {{ dirstate.stat.exists }}"

- name: Check that the jboss jar file already exists
  become: yes
  stat:
    path: "{{ jboss_rootdir + '/' + jboss_jarfile }}"
  register: jarstate

- debug:
    msg: "filepath {{ jboss_rootdir + '/' + jboss_jarfile }} state exists {{ jarstate.stat.exists }}"

- name: Create subdir for jboss app if not exists
  become: yes
  file:
    path: "{{ jboss_rootdir }}"
    state: directory
    mode: 0755
  when: dirstate.stat.exists == False

- name: Check that the jboss directory exists or not
  become: yes
  stat:
    path: "{{ jboss_rootdir }}"
  register: dirstate

- debug:
    msg: "filepath {{ jboss_rootdir }} state exists {{ dirstate.stat.exists }}"

- name: Check that the jboss source zip in tmp exists or not
  become: yes
  stat:
    path: "/tmp/{{ jboss_zipfilename }}"
  register: local_jboss_zipfile

- debug:
    msg: "(/tmp/{{ jboss_zipfilename }}) exist in tmp {{ local_jboss_zipfile.stat.exists }}"
  
- name: unpack JBOSS zip from tmp and Unarchive
  become: yes
  unarchive:
    src: "/tmp/{{ jboss_zipfilename }}"
    dest: "{{ jboss_unzip_dirname }}"
    creates: "{{ jboss_rootdir + '/' + jboss_jarfile }}"
  when: jarstate.stat.exists == False and  dirstate.stat.exists == True and local_jboss_zipfile.stat.exists == True
#  with_items:
#    - "{{ (local_jboss_zipfile.stat.exists)|{src: "/tmp/{{ jboss_zipfilename }}", remote_src: no} }}"
#    - "{{ (local_jboss_zipfile.stat.exists == False)|{src: "{{ jboss_repo }}", remote_src: yes} }}"     

- name: Download JBOSS zip and Unarchive
  become: yes
  unarchive:
    src: "{{ jboss_repo }}"
    dest: "{{ jboss_unzip_dirname }}"
    creates: "{{ jboss_rootdir + '/' + jboss_jarfile }}"
    remote_src: yes
  when: jarstate.stat.exists == False and  dirstate.stat.exists == True and local_jboss_zipfile.stat.exists == True

- debug:
    msg: "clause to download zip was  when:{{ jarstate.stat.exists == False and  dirstate.stat.exists == True }}"

- name: Check that the jboss jar file exists or not
  become: yes
  stat:
    path: "{{ jboss_rootdir + '/' + jboss_jarfile }}"
  register: jarstate
 
- debug:
    msg: "filepath {{ jboss_rootdir + '/' + jboss_jarfile }} state exists {{ jarstate.stat.exists }}"

- name: stop if jboss not unpacked
  fail:
  when: jarstate.stat.exists == False

 
- name: Ensure group for jboss service exists
  become: yes
  group:
    name: "{{ jboss_svc_username }}"
    state: present

- name: add OS user for jboss service
  become: yes
  user:
    name: "{{ jboss_svc_username }}"
    shell: "/sbin/nologin"
    home: "{{ jboss_rootdir }}"
    groups: "{{ jboss_svc_username }}"
    
    
- name: set owner for jboss folder
  become: yes
  file:
    path: "{{ jboss_rootdir }}"
    recurse: yes
    owner: "{{ jboss_svc_username }}"
    group: "{{ jboss_svc_username }}"
    mode: 0755

# issue with jboss jar workaround (see https://stackoverflow.com/questions/48403832/javax-xml-parsers-factoryconfigurationerror-running-jboss-as-7-1-with-java-7-upd)
- name: hotfix for jboss-modules.jar
  become: yes
  become_method: sudo
  become_user: "{{ jboss_svc_username }}"
  get_url:
# comment remote url for tests
#    url: "{{ jboss_hotfix }}"
    url: file:///tmp/jboss-modules-1.1.5.GA.jar
    dest: "{{ jboss_rootdir }}/jboss-modules.jar"
    force: yes
  when: jboss_repo == "http://download.jboss.org/jbossas/7.1/jboss-as-7.1.1.Final/jboss-as-7.1.1.Final.zip"    

- debug:
    msg: "command for next task: fgrep -c {{ jboss_mgmt_username }} {{ jboss_rootdir }}/standalone/configuration/mgmt-users.properties"

- name: Check that the jboss mgmt exist
  become: yes
  command: "fgrep -c {{ jboss_mgmt_username }} {{ jboss_rootdir }}/standalone/configuration/mgmt-users.properties"
  register: mgmt_usr_exist
  ignore_errors: yes
# hint: fgrep -c returns count of string (e.g. zero if nothing found, 1 if user exist, 2 and more if something go wrong )   
# returned value in registered var is 'string', but returncode (.rc) of grep is 1 if not found
- debug:
    msg: "mgmt_usr_exist='{{ mgmt_usr_exist }}'"

- debug:
    msg: "command for next task: {{ jboss_bindir }}/add-user.sh -s {{ jboss_mgmt_username }} {{ jboss_mgmt_pass }}"

- name: add jboss mgmt user
  become: yes
  become_method: sudo
  become_user: "{{ jboss_svc_username }}"
  command: "{{ jboss_bindir }}/add-user.sh -s {{ jboss_mgmt_username }} {{ jboss_mgmt_pass }}"
  when: "mgmt_usr_exist.rc == 1" 
#    - "{{ jboss_bindir }}/add-user.sh -s -a {{ jboss_app_username }} {{ jboss_app_pass }}"

- debug:
    msg: "command for next task: fgrep -c {{ jboss_mgmt_username }} {{ jboss_rootdir }}/standalone/configuration/mgmt-users.properties"

- name: Check that the jboss app user exist
  become: yes
  ignore_errors: yes
  command: "fgrep -c {{ jboss_app_username }} {{ jboss_rootdir }}/standalone/configuration/mgmt-users.properties"
  register: app_usr_exist
  failed_when: "app_usr_exist.rc == 1"

- debug:
    msg: "command for next task: {{ jboss_bindir }}/add-user.sh -s -a {{ jboss_app_username }} {{ jboss_app_pass }}"

- name: add jboss app user
  become: yes
  become_method: sudo
  become_user: "{{ jboss_svc_username }}"
  command: "{{ jboss_bindir }}/add-user.sh -s -a {{ jboss_app_username }} {{ jboss_app_pass }}"
  when: app_usr_exist == 0 


#fgrep jbossmgmt /usr/local/share/wildfly/jboss-as-7.1.1.Final/standalone/configuration/mgmt-users.properties
#fgrep jbossapp /usr/local/share/wildfly/jboss-as-7.1.1.Final/standalone/configuration/application-users.properties

- name: create wildfly config file
  become: yes
  become_method: sudo
  template:
    src: wildfly.conf.j2
    dest: /etc/default/wildfly.conf
    owner: root
    group: root
    mode: '0644'
    backup: yes
  notify:
      - reload systemctl    

- name: create wildfly service file
  become: yes
  become_method: sudo
  template:
    src: wildfly.service.j2
    dest: /etc/systemd/system/wildfly.service
    owner: root
    group: root
    mode: '0644'
    backup: yes        

- name: create wildfly startup stript
  become: yes
  become_method: sudo
  become_user: "{{ jboss_svc_username }}"
  template:
    src: launch.sh.j2
    dest: "{{ jboss_bindir }}/launch.sh"
    owner: "{{ jboss_svc_username }}"
    group: "{{ jboss_svc_username }}"
    mode: '0755'
    backup: yes   
    
- name: Make sure wildfly service is running
  become: yes
  become_method: sudo
  systemd: state=started name=wildfly.service  enabled=yes

#restart webservice
# /standalone/configuration/standalone.xml 127.0.0.1
#            <inet-address value="${jboss.bind.address.management:0.0.0.0}"/>
#            <inet-address value="${jboss.bind.address:0.0.0.0}"/>
# sed -i 's/original/new/g'
# put a \ before any of $ * . [ \ ^ to get the literal character

#- name: using old good sed
#  command: 'sed -i s/jboss\.bind\.address\.management\:127\.0\.0\.0/jboss\.bind\.address\.management\:0\.0\.0\.0/g +{{ jboss_rootdir}}+'/standalone/configuration/standalone.xml'
#  notify: restart webservice



- name: check if jboss/wildfly mgmt interface is on loopback address
  shell: 'netstat -na | fgrep -c "127.0.0.1:9990"'
  register: mgmt_bind_loopback
  ignore_errors: yes

- name: Wait 2 seconds for port 8080 to become open
  wait_for:
    port: 8080
    delay: 2
    timeout: 60

- name: Updating  standalone.xml to bind mgmt
  become: yes
  become_method: sudo
  become_user: "{{ jboss_svc_username }}"
  notify: restart webservice
  xml:
    path: "{{ jboss_rootdir}}/standalone/configuration/standalone.xml"
    xpath: /x:server/x:interfaces/x:interface[@name='management']/x:inet-address
    attribute: value
    namespaces:
      x: "urn:jboss:domain:6.0"
# original value="${jboss.bind.address.management:127.0.0.1} -> ip changing to inventory value"
# assuming we remember that /etc/ansible/hosts contain IPs
    value: "${jboss.bind.address.management:{{ hostvars[inventory_hostname]['groups']['web-servers'][0] }}}"
  when: mgmt_bind_loopback.stdout == "1" 
# no need to change binding for public interface because it done in wildfly.conf to all interfaces (WILDFLY_BIND=0.0.0.0)

- name: Wait 2 seconds for port 8080 to become open
  wait_for:
    port: 8080
    delay: 2
    timeout: 60

- name: Check wildfly web-service is running or not vs HTTPS 
  uri:
    url: https://localhost:8443
    validate_certs: False
    return_content: yes
  register: httpswebpage

- name: Fail if jboss.org is not in the page content
  fail:
  when: "'JBoss' not in httpswebpage.content"

- name: Check wildfly web-service is running or not vs HTTP 
  uri:
    url: http://localhost:8080
    return_content: yes
  register: httpwebpage

- name: Fail if jboss.org is not in the page content
  fail:
  when: "'JBoss' not in httpwebpage.content"          